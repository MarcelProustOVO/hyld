// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SocketProto.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_SocketProto_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_SocketProto_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_SocketProto_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_SocketProto_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_SocketProto_2eproto;
namespace SocketProto {
class ChatPack;
class ChatPackDefaultTypeInternal;
extern ChatPackDefaultTypeInternal _ChatPack_default_instance_;
class FriendRoomPack;
class FriendRoomPackDefaultTypeInternal;
extern FriendRoomPackDefaultTypeInternal _FriendRoomPack_default_instance_;
class LoginPack;
class LoginPackDefaultTypeInternal;
extern LoginPackDefaultTypeInternal _LoginPack_default_instance_;
class MainPack;
class MainPackDefaultTypeInternal;
extern MainPackDefaultTypeInternal _MainPack_default_instance_;
class PlayerPack;
class PlayerPackDefaultTypeInternal;
extern PlayerPackDefaultTypeInternal _PlayerPack_default_instance_;
class RoomPack;
class RoomPackDefaultTypeInternal;
extern RoomPackDefaultTypeInternal _RoomPack_default_instance_;
}  // namespace SocketProto
PROTOBUF_NAMESPACE_OPEN
template<> ::SocketProto::ChatPack* Arena::CreateMaybeMessage<::SocketProto::ChatPack>(Arena*);
template<> ::SocketProto::FriendRoomPack* Arena::CreateMaybeMessage<::SocketProto::FriendRoomPack>(Arena*);
template<> ::SocketProto::LoginPack* Arena::CreateMaybeMessage<::SocketProto::LoginPack>(Arena*);
template<> ::SocketProto::MainPack* Arena::CreateMaybeMessage<::SocketProto::MainPack>(Arena*);
template<> ::SocketProto::PlayerPack* Arena::CreateMaybeMessage<::SocketProto::PlayerPack>(Arena*);
template<> ::SocketProto::RoomPack* Arena::CreateMaybeMessage<::SocketProto::RoomPack>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace SocketProto {

enum RequestCode : int {
  RequestNone = 0,
  User = 1,
  Room = 2,
  Friend = 3,
  FriendRoom = 4,
  PingPong = 5,
  RequestCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RequestCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RequestCode_IsValid(int value);
constexpr RequestCode RequestCode_MIN = RequestNone;
constexpr RequestCode RequestCode_MAX = PingPong;
constexpr int RequestCode_ARRAYSIZE = RequestCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RequestCode_descriptor();
template<typename T>
inline const std::string& RequestCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RequestCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RequestCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RequestCode_descriptor(), enum_t_value);
}
inline bool RequestCode_Parse(
    const std::string& name, RequestCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RequestCode>(
    RequestCode_descriptor(), name, value);
}
enum ActionCode : int {
  ActionNone = 0,
  Logon = 1,
  Login = 2,
  CreateRoom = 3,
  FindRoom = 4,
  PlayerList = 5,
  JoinRoom = 6,
  Exit = 7,
  Chat = 8,
  AplyAddFriend = 9,
  InviteFriend = 10,
  FindName = 11,
  UpdateName = 12,
  AcceptAddFriend = 13,
  RejectAddFriend = 14,
  FindPlayerInfo = 15,
  FindFriendsInfo = 16,
  FriendLogin = 17,
  FriendLogout = 18,
  AcceptInvateFriend = 19,
  RejectInvateFriend = 20,
  CancalInvateFriend = 21,
  ExitRoom = 22,
  GetFriendRoomInfo = 23,
  Ping = 24,
  Pong = 25,
  ChangeHero = 26,
  UpDateActiveFriendInfo = 27,
  ActionCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ActionCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ActionCode_IsValid(int value);
constexpr ActionCode ActionCode_MIN = ActionNone;
constexpr ActionCode ActionCode_MAX = UpDateActiveFriendInfo;
constexpr int ActionCode_ARRAYSIZE = ActionCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActionCode_descriptor();
template<typename T>
inline const std::string& ActionCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActionCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActionCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActionCode_descriptor(), enum_t_value);
}
inline bool ActionCode_Parse(
    const std::string& name, ActionCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActionCode>(
    ActionCode_descriptor(), name, value);
}
enum ReturnCode : int {
  ReturnNone = 0,
  Succeed = 1,
  Fail = 2,
  NotRoom = 3,
  AddFriend = 4,
  ReturnCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ReturnCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ReturnCode_IsValid(int value);
constexpr ReturnCode ReturnCode_MIN = ReturnNone;
constexpr ReturnCode ReturnCode_MAX = AddFriend;
constexpr int ReturnCode_ARRAYSIZE = ReturnCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReturnCode_descriptor();
template<typename T>
inline const std::string& ReturnCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReturnCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReturnCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ReturnCode_descriptor(), enum_t_value);
}
inline bool ReturnCode_Parse(
    const std::string& name, ReturnCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ReturnCode>(
    ReturnCode_descriptor(), name, value);
}
enum RoomState : int {
  RoomNormal = 0,
  RoomFull = 1,
  RoomGame = 2,
  RoomState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RoomState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RoomState_IsValid(int value);
constexpr RoomState RoomState_MIN = RoomNormal;
constexpr RoomState RoomState_MAX = RoomGame;
constexpr int RoomState_ARRAYSIZE = RoomState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RoomState_descriptor();
template<typename T>
inline const std::string& RoomState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoomState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoomState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RoomState_descriptor(), enum_t_value);
}
inline bool RoomState_Parse(
    const std::string& name, RoomState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RoomState>(
    RoomState_descriptor(), name, value);
}
enum PlayerState : int {
  PlayerOnline = 0,
  PlayerOutline = 1,
  PlayerGame = 2,
  PlayerOnRoom = 3,
  PlayerOnInvated = 4,
  PlayerState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PlayerState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PlayerState_IsValid(int value);
constexpr PlayerState PlayerState_MIN = PlayerOnline;
constexpr PlayerState PlayerState_MAX = PlayerOnInvated;
constexpr int PlayerState_ARRAYSIZE = PlayerState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayerState_descriptor();
template<typename T>
inline const std::string& PlayerState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlayerState_descriptor(), enum_t_value);
}
inline bool PlayerState_Parse(
    const std::string& name, PlayerState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayerState>(
    PlayerState_descriptor(), name, value);
}
enum Hero : int {
  XueLi = 0,
  KeErTe = 1,
  PeiPei = 2,
  PanNi = 3,
  BaLi = 4,
  GongNiu = 5,
  DaLiEr = 6,
  GeEr = 7,
  BuLuoKe = 8,
  BaoPoMaiKe = 9,
  ABo = 10,
  DiKe = 11,
  BeiYa = 12,
  TaLa = 13,
  MaiKeSi = 14,
  SiPaiKe = 15,
  HeiYa = 16,
  LiAng = 17,
  PaMu = 18,
  RuiKe = 19,
  Hero_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Hero_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Hero_IsValid(int value);
constexpr Hero Hero_MIN = XueLi;
constexpr Hero Hero_MAX = RuiKe;
constexpr int Hero_ARRAYSIZE = Hero_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Hero_descriptor();
template<typename T>
inline const std::string& Hero_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Hero>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Hero_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Hero_descriptor(), enum_t_value);
}
inline bool Hero_Parse(
    const std::string& name, Hero* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Hero>(
    Hero_descriptor(), name, value);
}
// ===================================================================

class MainPack :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SocketProto.MainPack) */ {
 public:
  MainPack();
  virtual ~MainPack();

  MainPack(const MainPack& from);
  MainPack(MainPack&& from) noexcept
    : MainPack() {
    *this = ::std::move(from);
  }

  inline MainPack& operator=(const MainPack& from) {
    CopyFrom(from);
    return *this;
  }
  inline MainPack& operator=(MainPack&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MainPack& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MainPack* internal_default_instance() {
    return reinterpret_cast<const MainPack*>(
               &_MainPack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MainPack& a, MainPack& b) {
    a.Swap(&b);
  }
  inline void Swap(MainPack* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MainPack* New() const final {
    return CreateMaybeMessage<MainPack>(nullptr);
  }

  MainPack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MainPack>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MainPack& from);
  void MergeFrom(const MainPack& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MainPack* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SocketProto.MainPack";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SocketProto_2eproto);
    return ::descriptor_table_SocketProto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoompackFieldNumber = 6,
    kFriendspackFieldNumber = 7,
    kFriendroompackFieldNumber = 9,
    kPlayerspackFieldNumber = 10,
    kStrFieldNumber = 5,
    kLoginpackFieldNumber = 4,
    kUserInfopackFieldNumber = 8,
    kChatpackFieldNumber = 11,
    kRequestcodeFieldNumber = 1,
    kActioncodeFieldNumber = 2,
    kReturncodeFieldNumber = 3,
  };
  // repeated .SocketProto.RoomPack roompack = 6;
  int roompack_size() const;
  private:
  int _internal_roompack_size() const;
  public:
  void clear_roompack();
  ::SocketProto::RoomPack* mutable_roompack(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SocketProto::RoomPack >*
      mutable_roompack();
  private:
  const ::SocketProto::RoomPack& _internal_roompack(int index) const;
  ::SocketProto::RoomPack* _internal_add_roompack();
  public:
  const ::SocketProto::RoomPack& roompack(int index) const;
  ::SocketProto::RoomPack* add_roompack();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SocketProto::RoomPack >&
      roompack() const;

  // repeated .SocketProto.PlayerPack friendspack = 7;
  int friendspack_size() const;
  private:
  int _internal_friendspack_size() const;
  public:
  void clear_friendspack();
  ::SocketProto::PlayerPack* mutable_friendspack(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SocketProto::PlayerPack >*
      mutable_friendspack();
  private:
  const ::SocketProto::PlayerPack& _internal_friendspack(int index) const;
  ::SocketProto::PlayerPack* _internal_add_friendspack();
  public:
  const ::SocketProto::PlayerPack& friendspack(int index) const;
  ::SocketProto::PlayerPack* add_friendspack();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SocketProto::PlayerPack >&
      friendspack() const;

  // repeated .SocketProto.FriendRoomPack friendroompack = 9;
  int friendroompack_size() const;
  private:
  int _internal_friendroompack_size() const;
  public:
  void clear_friendroompack();
  ::SocketProto::FriendRoomPack* mutable_friendroompack(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SocketProto::FriendRoomPack >*
      mutable_friendroompack();
  private:
  const ::SocketProto::FriendRoomPack& _internal_friendroompack(int index) const;
  ::SocketProto::FriendRoomPack* _internal_add_friendroompack();
  public:
  const ::SocketProto::FriendRoomPack& friendroompack(int index) const;
  ::SocketProto::FriendRoomPack* add_friendroompack();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SocketProto::FriendRoomPack >&
      friendroompack() const;

  // repeated .SocketProto.PlayerPack playerspack = 10;
  int playerspack_size() const;
  private:
  int _internal_playerspack_size() const;
  public:
  void clear_playerspack();
  ::SocketProto::PlayerPack* mutable_playerspack(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SocketProto::PlayerPack >*
      mutable_playerspack();
  private:
  const ::SocketProto::PlayerPack& _internal_playerspack(int index) const;
  ::SocketProto::PlayerPack* _internal_add_playerspack();
  public:
  const ::SocketProto::PlayerPack& playerspack(int index) const;
  ::SocketProto::PlayerPack* add_playerspack();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SocketProto::PlayerPack >&
      playerspack() const;

  // string str = 5;
  void clear_str();
  const std::string& str() const;
  void set_str(const std::string& value);
  void set_str(std::string&& value);
  void set_str(const char* value);
  void set_str(const char* value, size_t size);
  std::string* mutable_str();
  std::string* release_str();
  void set_allocated_str(std::string* str);
  private:
  const std::string& _internal_str() const;
  void _internal_set_str(const std::string& value);
  std::string* _internal_mutable_str();
  public:

  // .SocketProto.LoginPack loginpack = 4;
  bool has_loginpack() const;
  private:
  bool _internal_has_loginpack() const;
  public:
  void clear_loginpack();
  const ::SocketProto::LoginPack& loginpack() const;
  ::SocketProto::LoginPack* release_loginpack();
  ::SocketProto::LoginPack* mutable_loginpack();
  void set_allocated_loginpack(::SocketProto::LoginPack* loginpack);
  private:
  const ::SocketProto::LoginPack& _internal_loginpack() const;
  ::SocketProto::LoginPack* _internal_mutable_loginpack();
  public:

  // .SocketProto.PlayerPack userInfopack = 8;
  bool has_userinfopack() const;
  private:
  bool _internal_has_userinfopack() const;
  public:
  void clear_userinfopack();
  const ::SocketProto::PlayerPack& userinfopack() const;
  ::SocketProto::PlayerPack* release_userinfopack();
  ::SocketProto::PlayerPack* mutable_userinfopack();
  void set_allocated_userinfopack(::SocketProto::PlayerPack* userinfopack);
  private:
  const ::SocketProto::PlayerPack& _internal_userinfopack() const;
  ::SocketProto::PlayerPack* _internal_mutable_userinfopack();
  public:

  // .SocketProto.ChatPack chatpack = 11;
  bool has_chatpack() const;
  private:
  bool _internal_has_chatpack() const;
  public:
  void clear_chatpack();
  const ::SocketProto::ChatPack& chatpack() const;
  ::SocketProto::ChatPack* release_chatpack();
  ::SocketProto::ChatPack* mutable_chatpack();
  void set_allocated_chatpack(::SocketProto::ChatPack* chatpack);
  private:
  const ::SocketProto::ChatPack& _internal_chatpack() const;
  ::SocketProto::ChatPack* _internal_mutable_chatpack();
  public:

  // .SocketProto.RequestCode requestcode = 1;
  void clear_requestcode();
  ::SocketProto::RequestCode requestcode() const;
  void set_requestcode(::SocketProto::RequestCode value);
  private:
  ::SocketProto::RequestCode _internal_requestcode() const;
  void _internal_set_requestcode(::SocketProto::RequestCode value);
  public:

  // .SocketProto.ActionCode actioncode = 2;
  void clear_actioncode();
  ::SocketProto::ActionCode actioncode() const;
  void set_actioncode(::SocketProto::ActionCode value);
  private:
  ::SocketProto::ActionCode _internal_actioncode() const;
  void _internal_set_actioncode(::SocketProto::ActionCode value);
  public:

  // .SocketProto.ReturnCode returncode = 3;
  void clear_returncode();
  ::SocketProto::ReturnCode returncode() const;
  void set_returncode(::SocketProto::ReturnCode value);
  private:
  ::SocketProto::ReturnCode _internal_returncode() const;
  void _internal_set_returncode(::SocketProto::ReturnCode value);
  public:

  // @@protoc_insertion_point(class_scope:SocketProto.MainPack)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SocketProto::RoomPack > roompack_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SocketProto::PlayerPack > friendspack_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SocketProto::FriendRoomPack > friendroompack_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SocketProto::PlayerPack > playerspack_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr str_;
  ::SocketProto::LoginPack* loginpack_;
  ::SocketProto::PlayerPack* userinfopack_;
  ::SocketProto::ChatPack* chatpack_;
  int requestcode_;
  int actioncode_;
  int returncode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_SocketProto_2eproto;
};
// -------------------------------------------------------------------

class ChatPack :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SocketProto.ChatPack) */ {
 public:
  ChatPack();
  virtual ~ChatPack();

  ChatPack(const ChatPack& from);
  ChatPack(ChatPack&& from) noexcept
    : ChatPack() {
    *this = ::std::move(from);
  }

  inline ChatPack& operator=(const ChatPack& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatPack& operator=(ChatPack&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChatPack& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChatPack* internal_default_instance() {
    return reinterpret_cast<const ChatPack*>(
               &_ChatPack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ChatPack& a, ChatPack& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatPack* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChatPack* New() const final {
    return CreateMaybeMessage<ChatPack>(nullptr);
  }

  ChatPack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChatPack>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChatPack& from);
  void MergeFrom(const ChatPack& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatPack* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SocketProto.ChatPack";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SocketProto_2eproto);
    return ::descriptor_table_SocketProto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayernameFieldNumber = 1,
    kMessageFieldNumber = 2,
    kStateFieldNumber = 3,
  };
  // string playername = 1;
  void clear_playername();
  const std::string& playername() const;
  void set_playername(const std::string& value);
  void set_playername(std::string&& value);
  void set_playername(const char* value);
  void set_playername(const char* value, size_t size);
  std::string* mutable_playername();
  std::string* release_playername();
  void set_allocated_playername(std::string* playername);
  private:
  const std::string& _internal_playername() const;
  void _internal_set_playername(const std::string& value);
  std::string* _internal_mutable_playername();
  public:

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int32 state = 3;
  void clear_state();
  ::PROTOBUF_NAMESPACE_ID::int32 state() const;
  void set_state(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_state() const;
  void _internal_set_state(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:SocketProto.ChatPack)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playername_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::int32 state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_SocketProto_2eproto;
};
// -------------------------------------------------------------------

class LoginPack :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SocketProto.LoginPack) */ {
 public:
  LoginPack();
  virtual ~LoginPack();

  LoginPack(const LoginPack& from);
  LoginPack(LoginPack&& from) noexcept
    : LoginPack() {
    *this = ::std::move(from);
  }

  inline LoginPack& operator=(const LoginPack& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginPack& operator=(LoginPack&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoginPack& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginPack* internal_default_instance() {
    return reinterpret_cast<const LoginPack*>(
               &_LoginPack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LoginPack& a, LoginPack& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginPack* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoginPack* New() const final {
    return CreateMaybeMessage<LoginPack>(nullptr);
  }

  LoginPack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginPack>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoginPack& from);
  void MergeFrom(const LoginPack& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginPack* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SocketProto.LoginPack";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SocketProto_2eproto);
    return ::descriptor_table_SocketProto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:SocketProto.LoginPack)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_SocketProto_2eproto;
};
// -------------------------------------------------------------------

class RoomPack :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SocketProto.RoomPack) */ {
 public:
  RoomPack();
  virtual ~RoomPack();

  RoomPack(const RoomPack& from);
  RoomPack(RoomPack&& from) noexcept
    : RoomPack() {
    *this = ::std::move(from);
  }

  inline RoomPack& operator=(const RoomPack& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomPack& operator=(RoomPack&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RoomPack& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomPack* internal_default_instance() {
    return reinterpret_cast<const RoomPack*>(
               &_RoomPack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RoomPack& a, RoomPack& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomPack* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoomPack* New() const final {
    return CreateMaybeMessage<RoomPack>(nullptr);
  }

  RoomPack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoomPack>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RoomPack& from);
  void MergeFrom(const RoomPack& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomPack* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SocketProto.RoomPack";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SocketProto_2eproto);
    return ::descriptor_table_SocketProto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomidFieldNumber = 1,
    kMaxnumFieldNumber = 2,
    kCurnumFieldNumber = 3,
    kStateFieldNumber = 4,
  };
  // string roomid = 1;
  void clear_roomid();
  const std::string& roomid() const;
  void set_roomid(const std::string& value);
  void set_roomid(std::string&& value);
  void set_roomid(const char* value);
  void set_roomid(const char* value, size_t size);
  std::string* mutable_roomid();
  std::string* release_roomid();
  void set_allocated_roomid(std::string* roomid);
  private:
  const std::string& _internal_roomid() const;
  void _internal_set_roomid(const std::string& value);
  std::string* _internal_mutable_roomid();
  public:

  // int32 maxnum = 2;
  void clear_maxnum();
  ::PROTOBUF_NAMESPACE_ID::int32 maxnum() const;
  void set_maxnum(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_maxnum() const;
  void _internal_set_maxnum(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 curnum = 3;
  void clear_curnum();
  ::PROTOBUF_NAMESPACE_ID::int32 curnum() const;
  void set_curnum(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_curnum() const;
  void _internal_set_curnum(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .SocketProto.RoomState state = 4;
  void clear_state();
  ::SocketProto::RoomState state() const;
  void set_state(::SocketProto::RoomState value);
  private:
  ::SocketProto::RoomState _internal_state() const;
  void _internal_set_state(::SocketProto::RoomState value);
  public:

  // @@protoc_insertion_point(class_scope:SocketProto.RoomPack)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roomid_;
  ::PROTOBUF_NAMESPACE_ID::int32 maxnum_;
  ::PROTOBUF_NAMESPACE_ID::int32 curnum_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_SocketProto_2eproto;
};
// -------------------------------------------------------------------

class FriendRoomPack :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SocketProto.FriendRoomPack) */ {
 public:
  FriendRoomPack();
  virtual ~FriendRoomPack();

  FriendRoomPack(const FriendRoomPack& from);
  FriendRoomPack(FriendRoomPack&& from) noexcept
    : FriendRoomPack() {
    *this = ::std::move(from);
  }

  inline FriendRoomPack& operator=(const FriendRoomPack& from) {
    CopyFrom(from);
    return *this;
  }
  inline FriendRoomPack& operator=(FriendRoomPack&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FriendRoomPack& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FriendRoomPack* internal_default_instance() {
    return reinterpret_cast<const FriendRoomPack*>(
               &_FriendRoomPack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FriendRoomPack& a, FriendRoomPack& b) {
    a.Swap(&b);
  }
  inline void Swap(FriendRoomPack* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FriendRoomPack* New() const final {
    return CreateMaybeMessage<FriendRoomPack>(nullptr);
  }

  FriendRoomPack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FriendRoomPack>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FriendRoomPack& from);
  void MergeFrom(const FriendRoomPack& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FriendRoomPack* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SocketProto.FriendRoomPack";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SocketProto_2eproto);
    return ::descriptor_table_SocketProto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomidFieldNumber = 1,
    kMaxnumFieldNumber = 2,
    kCurnumFieldNumber = 3,
    kStateFieldNumber = 4,
  };
  // string roomid = 1;
  void clear_roomid();
  const std::string& roomid() const;
  void set_roomid(const std::string& value);
  void set_roomid(std::string&& value);
  void set_roomid(const char* value);
  void set_roomid(const char* value, size_t size);
  std::string* mutable_roomid();
  std::string* release_roomid();
  void set_allocated_roomid(std::string* roomid);
  private:
  const std::string& _internal_roomid() const;
  void _internal_set_roomid(const std::string& value);
  std::string* _internal_mutable_roomid();
  public:

  // int32 maxnum = 2;
  void clear_maxnum();
  ::PROTOBUF_NAMESPACE_ID::int32 maxnum() const;
  void set_maxnum(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_maxnum() const;
  void _internal_set_maxnum(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 curnum = 3;
  void clear_curnum();
  ::PROTOBUF_NAMESPACE_ID::int32 curnum() const;
  void set_curnum(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_curnum() const;
  void _internal_set_curnum(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .SocketProto.RoomState state = 4;
  void clear_state();
  ::SocketProto::RoomState state() const;
  void set_state(::SocketProto::RoomState value);
  private:
  ::SocketProto::RoomState _internal_state() const;
  void _internal_set_state(::SocketProto::RoomState value);
  public:

  // @@protoc_insertion_point(class_scope:SocketProto.FriendRoomPack)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roomid_;
  ::PROTOBUF_NAMESPACE_ID::int32 maxnum_;
  ::PROTOBUF_NAMESPACE_ID::int32 curnum_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_SocketProto_2eproto;
};
// -------------------------------------------------------------------

class PlayerPack :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SocketProto.PlayerPack) */ {
 public:
  PlayerPack();
  virtual ~PlayerPack();

  PlayerPack(const PlayerPack& from);
  PlayerPack(PlayerPack&& from) noexcept
    : PlayerPack() {
    *this = ::std::move(from);
  }

  inline PlayerPack& operator=(const PlayerPack& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerPack& operator=(PlayerPack&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerPack& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerPack* internal_default_instance() {
    return reinterpret_cast<const PlayerPack*>(
               &_PlayerPack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PlayerPack& a, PlayerPack& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerPack* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerPack* New() const final {
    return CreateMaybeMessage<PlayerPack>(nullptr);
  }

  PlayerPack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerPack>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerPack& from);
  void MergeFrom(const PlayerPack& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerPack* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SocketProto.PlayerPack";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_SocketProto_2eproto);
    return ::descriptor_table_SocketProto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPlayernameFieldNumber = 2,
    kIdFieldNumber = 3,
    kStateFieldNumber = 4,
    kHeroFieldNumber = 5,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string playername = 2;
  void clear_playername();
  const std::string& playername() const;
  void set_playername(const std::string& value);
  void set_playername(std::string&& value);
  void set_playername(const char* value);
  void set_playername(const char* value, size_t size);
  std::string* mutable_playername();
  std::string* release_playername();
  void set_allocated_playername(std::string* playername);
  private:
  const std::string& _internal_playername() const;
  void _internal_set_playername(const std::string& value);
  std::string* _internal_mutable_playername();
  public:

  // int32 id = 3;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .SocketProto.PlayerState state = 4;
  void clear_state();
  ::SocketProto::PlayerState state() const;
  void set_state(::SocketProto::PlayerState value);
  private:
  ::SocketProto::PlayerState _internal_state() const;
  void _internal_set_state(::SocketProto::PlayerState value);
  public:

  // .SocketProto.Hero hero = 5;
  void clear_hero();
  ::SocketProto::Hero hero() const;
  void set_hero(::SocketProto::Hero value);
  private:
  ::SocketProto::Hero _internal_hero() const;
  void _internal_set_hero(::SocketProto::Hero value);
  public:

  // @@protoc_insertion_point(class_scope:SocketProto.PlayerPack)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playername_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  int state_;
  int hero_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_SocketProto_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MainPack

// .SocketProto.RequestCode requestcode = 1;
inline void MainPack::clear_requestcode() {
  requestcode_ = 0;
}
inline ::SocketProto::RequestCode MainPack::_internal_requestcode() const {
  return static_cast< ::SocketProto::RequestCode >(requestcode_);
}
inline ::SocketProto::RequestCode MainPack::requestcode() const {
  // @@protoc_insertion_point(field_get:SocketProto.MainPack.requestcode)
  return _internal_requestcode();
}
inline void MainPack::_internal_set_requestcode(::SocketProto::RequestCode value) {
  
  requestcode_ = value;
}
inline void MainPack::set_requestcode(::SocketProto::RequestCode value) {
  _internal_set_requestcode(value);
  // @@protoc_insertion_point(field_set:SocketProto.MainPack.requestcode)
}

// .SocketProto.ActionCode actioncode = 2;
inline void MainPack::clear_actioncode() {
  actioncode_ = 0;
}
inline ::SocketProto::ActionCode MainPack::_internal_actioncode() const {
  return static_cast< ::SocketProto::ActionCode >(actioncode_);
}
inline ::SocketProto::ActionCode MainPack::actioncode() const {
  // @@protoc_insertion_point(field_get:SocketProto.MainPack.actioncode)
  return _internal_actioncode();
}
inline void MainPack::_internal_set_actioncode(::SocketProto::ActionCode value) {
  
  actioncode_ = value;
}
inline void MainPack::set_actioncode(::SocketProto::ActionCode value) {
  _internal_set_actioncode(value);
  // @@protoc_insertion_point(field_set:SocketProto.MainPack.actioncode)
}

// .SocketProto.ReturnCode returncode = 3;
inline void MainPack::clear_returncode() {
  returncode_ = 0;
}
inline ::SocketProto::ReturnCode MainPack::_internal_returncode() const {
  return static_cast< ::SocketProto::ReturnCode >(returncode_);
}
inline ::SocketProto::ReturnCode MainPack::returncode() const {
  // @@protoc_insertion_point(field_get:SocketProto.MainPack.returncode)
  return _internal_returncode();
}
inline void MainPack::_internal_set_returncode(::SocketProto::ReturnCode value) {
  
  returncode_ = value;
}
inline void MainPack::set_returncode(::SocketProto::ReturnCode value) {
  _internal_set_returncode(value);
  // @@protoc_insertion_point(field_set:SocketProto.MainPack.returncode)
}

// .SocketProto.LoginPack loginpack = 4;
inline bool MainPack::_internal_has_loginpack() const {
  return this != internal_default_instance() && loginpack_ != nullptr;
}
inline bool MainPack::has_loginpack() const {
  return _internal_has_loginpack();
}
inline void MainPack::clear_loginpack() {
  if (GetArenaNoVirtual() == nullptr && loginpack_ != nullptr) {
    delete loginpack_;
  }
  loginpack_ = nullptr;
}
inline const ::SocketProto::LoginPack& MainPack::_internal_loginpack() const {
  const ::SocketProto::LoginPack* p = loginpack_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SocketProto::LoginPack*>(
      &::SocketProto::_LoginPack_default_instance_);
}
inline const ::SocketProto::LoginPack& MainPack::loginpack() const {
  // @@protoc_insertion_point(field_get:SocketProto.MainPack.loginpack)
  return _internal_loginpack();
}
inline ::SocketProto::LoginPack* MainPack::release_loginpack() {
  // @@protoc_insertion_point(field_release:SocketProto.MainPack.loginpack)
  
  ::SocketProto::LoginPack* temp = loginpack_;
  loginpack_ = nullptr;
  return temp;
}
inline ::SocketProto::LoginPack* MainPack::_internal_mutable_loginpack() {
  
  if (loginpack_ == nullptr) {
    auto* p = CreateMaybeMessage<::SocketProto::LoginPack>(GetArenaNoVirtual());
    loginpack_ = p;
  }
  return loginpack_;
}
inline ::SocketProto::LoginPack* MainPack::mutable_loginpack() {
  // @@protoc_insertion_point(field_mutable:SocketProto.MainPack.loginpack)
  return _internal_mutable_loginpack();
}
inline void MainPack::set_allocated_loginpack(::SocketProto::LoginPack* loginpack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete loginpack_;
  }
  if (loginpack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      loginpack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loginpack, submessage_arena);
    }
    
  } else {
    
  }
  loginpack_ = loginpack;
  // @@protoc_insertion_point(field_set_allocated:SocketProto.MainPack.loginpack)
}

// string str = 5;
inline void MainPack::clear_str() {
  str_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& MainPack::str() const {
  // @@protoc_insertion_point(field_get:SocketProto.MainPack.str)
  return _internal_str();
}
inline void MainPack::set_str(const std::string& value) {
  _internal_set_str(value);
  // @@protoc_insertion_point(field_set:SocketProto.MainPack.str)
}
inline std::string* MainPack::mutable_str() {
  // @@protoc_insertion_point(field_mutable:SocketProto.MainPack.str)
  return _internal_mutable_str();
}
inline const std::string& MainPack::_internal_str() const {
  return str_.GetNoArena();
}
inline void MainPack::_internal_set_str(const std::string& value) {
  
  str_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void MainPack::set_str(std::string&& value) {
  
  str_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SocketProto.MainPack.str)
}
inline void MainPack::set_str(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  str_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SocketProto.MainPack.str)
}
inline void MainPack::set_str(const char* value, size_t size) {
  
  str_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SocketProto.MainPack.str)
}
inline std::string* MainPack::_internal_mutable_str() {
  
  return str_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MainPack::release_str() {
  // @@protoc_insertion_point(field_release:SocketProto.MainPack.str)
  
  return str_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MainPack::set_allocated_str(std::string* str) {
  if (str != nullptr) {
    
  } else {
    
  }
  str_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), str);
  // @@protoc_insertion_point(field_set_allocated:SocketProto.MainPack.str)
}

// repeated .SocketProto.RoomPack roompack = 6;
inline int MainPack::_internal_roompack_size() const {
  return roompack_.size();
}
inline int MainPack::roompack_size() const {
  return _internal_roompack_size();
}
inline void MainPack::clear_roompack() {
  roompack_.Clear();
}
inline ::SocketProto::RoomPack* MainPack::mutable_roompack(int index) {
  // @@protoc_insertion_point(field_mutable:SocketProto.MainPack.roompack)
  return roompack_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SocketProto::RoomPack >*
MainPack::mutable_roompack() {
  // @@protoc_insertion_point(field_mutable_list:SocketProto.MainPack.roompack)
  return &roompack_;
}
inline const ::SocketProto::RoomPack& MainPack::_internal_roompack(int index) const {
  return roompack_.Get(index);
}
inline const ::SocketProto::RoomPack& MainPack::roompack(int index) const {
  // @@protoc_insertion_point(field_get:SocketProto.MainPack.roompack)
  return _internal_roompack(index);
}
inline ::SocketProto::RoomPack* MainPack::_internal_add_roompack() {
  return roompack_.Add();
}
inline ::SocketProto::RoomPack* MainPack::add_roompack() {
  // @@protoc_insertion_point(field_add:SocketProto.MainPack.roompack)
  return _internal_add_roompack();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SocketProto::RoomPack >&
MainPack::roompack() const {
  // @@protoc_insertion_point(field_list:SocketProto.MainPack.roompack)
  return roompack_;
}

// repeated .SocketProto.PlayerPack friendspack = 7;
inline int MainPack::_internal_friendspack_size() const {
  return friendspack_.size();
}
inline int MainPack::friendspack_size() const {
  return _internal_friendspack_size();
}
inline void MainPack::clear_friendspack() {
  friendspack_.Clear();
}
inline ::SocketProto::PlayerPack* MainPack::mutable_friendspack(int index) {
  // @@protoc_insertion_point(field_mutable:SocketProto.MainPack.friendspack)
  return friendspack_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SocketProto::PlayerPack >*
MainPack::mutable_friendspack() {
  // @@protoc_insertion_point(field_mutable_list:SocketProto.MainPack.friendspack)
  return &friendspack_;
}
inline const ::SocketProto::PlayerPack& MainPack::_internal_friendspack(int index) const {
  return friendspack_.Get(index);
}
inline const ::SocketProto::PlayerPack& MainPack::friendspack(int index) const {
  // @@protoc_insertion_point(field_get:SocketProto.MainPack.friendspack)
  return _internal_friendspack(index);
}
inline ::SocketProto::PlayerPack* MainPack::_internal_add_friendspack() {
  return friendspack_.Add();
}
inline ::SocketProto::PlayerPack* MainPack::add_friendspack() {
  // @@protoc_insertion_point(field_add:SocketProto.MainPack.friendspack)
  return _internal_add_friendspack();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SocketProto::PlayerPack >&
MainPack::friendspack() const {
  // @@protoc_insertion_point(field_list:SocketProto.MainPack.friendspack)
  return friendspack_;
}

// .SocketProto.PlayerPack userInfopack = 8;
inline bool MainPack::_internal_has_userinfopack() const {
  return this != internal_default_instance() && userinfopack_ != nullptr;
}
inline bool MainPack::has_userinfopack() const {
  return _internal_has_userinfopack();
}
inline void MainPack::clear_userinfopack() {
  if (GetArenaNoVirtual() == nullptr && userinfopack_ != nullptr) {
    delete userinfopack_;
  }
  userinfopack_ = nullptr;
}
inline const ::SocketProto::PlayerPack& MainPack::_internal_userinfopack() const {
  const ::SocketProto::PlayerPack* p = userinfopack_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SocketProto::PlayerPack*>(
      &::SocketProto::_PlayerPack_default_instance_);
}
inline const ::SocketProto::PlayerPack& MainPack::userinfopack() const {
  // @@protoc_insertion_point(field_get:SocketProto.MainPack.userInfopack)
  return _internal_userinfopack();
}
inline ::SocketProto::PlayerPack* MainPack::release_userinfopack() {
  // @@protoc_insertion_point(field_release:SocketProto.MainPack.userInfopack)
  
  ::SocketProto::PlayerPack* temp = userinfopack_;
  userinfopack_ = nullptr;
  return temp;
}
inline ::SocketProto::PlayerPack* MainPack::_internal_mutable_userinfopack() {
  
  if (userinfopack_ == nullptr) {
    auto* p = CreateMaybeMessage<::SocketProto::PlayerPack>(GetArenaNoVirtual());
    userinfopack_ = p;
  }
  return userinfopack_;
}
inline ::SocketProto::PlayerPack* MainPack::mutable_userinfopack() {
  // @@protoc_insertion_point(field_mutable:SocketProto.MainPack.userInfopack)
  return _internal_mutable_userinfopack();
}
inline void MainPack::set_allocated_userinfopack(::SocketProto::PlayerPack* userinfopack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete userinfopack_;
  }
  if (userinfopack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      userinfopack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, userinfopack, submessage_arena);
    }
    
  } else {
    
  }
  userinfopack_ = userinfopack;
  // @@protoc_insertion_point(field_set_allocated:SocketProto.MainPack.userInfopack)
}

// repeated .SocketProto.FriendRoomPack friendroompack = 9;
inline int MainPack::_internal_friendroompack_size() const {
  return friendroompack_.size();
}
inline int MainPack::friendroompack_size() const {
  return _internal_friendroompack_size();
}
inline void MainPack::clear_friendroompack() {
  friendroompack_.Clear();
}
inline ::SocketProto::FriendRoomPack* MainPack::mutable_friendroompack(int index) {
  // @@protoc_insertion_point(field_mutable:SocketProto.MainPack.friendroompack)
  return friendroompack_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SocketProto::FriendRoomPack >*
MainPack::mutable_friendroompack() {
  // @@protoc_insertion_point(field_mutable_list:SocketProto.MainPack.friendroompack)
  return &friendroompack_;
}
inline const ::SocketProto::FriendRoomPack& MainPack::_internal_friendroompack(int index) const {
  return friendroompack_.Get(index);
}
inline const ::SocketProto::FriendRoomPack& MainPack::friendroompack(int index) const {
  // @@protoc_insertion_point(field_get:SocketProto.MainPack.friendroompack)
  return _internal_friendroompack(index);
}
inline ::SocketProto::FriendRoomPack* MainPack::_internal_add_friendroompack() {
  return friendroompack_.Add();
}
inline ::SocketProto::FriendRoomPack* MainPack::add_friendroompack() {
  // @@protoc_insertion_point(field_add:SocketProto.MainPack.friendroompack)
  return _internal_add_friendroompack();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SocketProto::FriendRoomPack >&
MainPack::friendroompack() const {
  // @@protoc_insertion_point(field_list:SocketProto.MainPack.friendroompack)
  return friendroompack_;
}

// repeated .SocketProto.PlayerPack playerspack = 10;
inline int MainPack::_internal_playerspack_size() const {
  return playerspack_.size();
}
inline int MainPack::playerspack_size() const {
  return _internal_playerspack_size();
}
inline void MainPack::clear_playerspack() {
  playerspack_.Clear();
}
inline ::SocketProto::PlayerPack* MainPack::mutable_playerspack(int index) {
  // @@protoc_insertion_point(field_mutable:SocketProto.MainPack.playerspack)
  return playerspack_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SocketProto::PlayerPack >*
MainPack::mutable_playerspack() {
  // @@protoc_insertion_point(field_mutable_list:SocketProto.MainPack.playerspack)
  return &playerspack_;
}
inline const ::SocketProto::PlayerPack& MainPack::_internal_playerspack(int index) const {
  return playerspack_.Get(index);
}
inline const ::SocketProto::PlayerPack& MainPack::playerspack(int index) const {
  // @@protoc_insertion_point(field_get:SocketProto.MainPack.playerspack)
  return _internal_playerspack(index);
}
inline ::SocketProto::PlayerPack* MainPack::_internal_add_playerspack() {
  return playerspack_.Add();
}
inline ::SocketProto::PlayerPack* MainPack::add_playerspack() {
  // @@protoc_insertion_point(field_add:SocketProto.MainPack.playerspack)
  return _internal_add_playerspack();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SocketProto::PlayerPack >&
MainPack::playerspack() const {
  // @@protoc_insertion_point(field_list:SocketProto.MainPack.playerspack)
  return playerspack_;
}

// .SocketProto.ChatPack chatpack = 11;
inline bool MainPack::_internal_has_chatpack() const {
  return this != internal_default_instance() && chatpack_ != nullptr;
}
inline bool MainPack::has_chatpack() const {
  return _internal_has_chatpack();
}
inline void MainPack::clear_chatpack() {
  if (GetArenaNoVirtual() == nullptr && chatpack_ != nullptr) {
    delete chatpack_;
  }
  chatpack_ = nullptr;
}
inline const ::SocketProto::ChatPack& MainPack::_internal_chatpack() const {
  const ::SocketProto::ChatPack* p = chatpack_;
  return p != nullptr ? *p : *reinterpret_cast<const ::SocketProto::ChatPack*>(
      &::SocketProto::_ChatPack_default_instance_);
}
inline const ::SocketProto::ChatPack& MainPack::chatpack() const {
  // @@protoc_insertion_point(field_get:SocketProto.MainPack.chatpack)
  return _internal_chatpack();
}
inline ::SocketProto::ChatPack* MainPack::release_chatpack() {
  // @@protoc_insertion_point(field_release:SocketProto.MainPack.chatpack)
  
  ::SocketProto::ChatPack* temp = chatpack_;
  chatpack_ = nullptr;
  return temp;
}
inline ::SocketProto::ChatPack* MainPack::_internal_mutable_chatpack() {
  
  if (chatpack_ == nullptr) {
    auto* p = CreateMaybeMessage<::SocketProto::ChatPack>(GetArenaNoVirtual());
    chatpack_ = p;
  }
  return chatpack_;
}
inline ::SocketProto::ChatPack* MainPack::mutable_chatpack() {
  // @@protoc_insertion_point(field_mutable:SocketProto.MainPack.chatpack)
  return _internal_mutable_chatpack();
}
inline void MainPack::set_allocated_chatpack(::SocketProto::ChatPack* chatpack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete chatpack_;
  }
  if (chatpack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      chatpack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chatpack, submessage_arena);
    }
    
  } else {
    
  }
  chatpack_ = chatpack;
  // @@protoc_insertion_point(field_set_allocated:SocketProto.MainPack.chatpack)
}

// -------------------------------------------------------------------

// ChatPack

// string playername = 1;
inline void ChatPack::clear_playername() {
  playername_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ChatPack::playername() const {
  // @@protoc_insertion_point(field_get:SocketProto.ChatPack.playername)
  return _internal_playername();
}
inline void ChatPack::set_playername(const std::string& value) {
  _internal_set_playername(value);
  // @@protoc_insertion_point(field_set:SocketProto.ChatPack.playername)
}
inline std::string* ChatPack::mutable_playername() {
  // @@protoc_insertion_point(field_mutable:SocketProto.ChatPack.playername)
  return _internal_mutable_playername();
}
inline const std::string& ChatPack::_internal_playername() const {
  return playername_.GetNoArena();
}
inline void ChatPack::_internal_set_playername(const std::string& value) {
  
  playername_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ChatPack::set_playername(std::string&& value) {
  
  playername_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SocketProto.ChatPack.playername)
}
inline void ChatPack::set_playername(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  playername_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SocketProto.ChatPack.playername)
}
inline void ChatPack::set_playername(const char* value, size_t size) {
  
  playername_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SocketProto.ChatPack.playername)
}
inline std::string* ChatPack::_internal_mutable_playername() {
  
  return playername_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChatPack::release_playername() {
  // @@protoc_insertion_point(field_release:SocketProto.ChatPack.playername)
  
  return playername_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChatPack::set_allocated_playername(std::string* playername) {
  if (playername != nullptr) {
    
  } else {
    
  }
  playername_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), playername);
  // @@protoc_insertion_point(field_set_allocated:SocketProto.ChatPack.playername)
}

// string message = 2;
inline void ChatPack::clear_message() {
  message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ChatPack::message() const {
  // @@protoc_insertion_point(field_get:SocketProto.ChatPack.message)
  return _internal_message();
}
inline void ChatPack::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:SocketProto.ChatPack.message)
}
inline std::string* ChatPack::mutable_message() {
  // @@protoc_insertion_point(field_mutable:SocketProto.ChatPack.message)
  return _internal_mutable_message();
}
inline const std::string& ChatPack::_internal_message() const {
  return message_.GetNoArena();
}
inline void ChatPack::_internal_set_message(const std::string& value) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ChatPack::set_message(std::string&& value) {
  
  message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SocketProto.ChatPack.message)
}
inline void ChatPack::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SocketProto.ChatPack.message)
}
inline void ChatPack::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SocketProto.ChatPack.message)
}
inline std::string* ChatPack::_internal_mutable_message() {
  
  return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChatPack::release_message() {
  // @@protoc_insertion_point(field_release:SocketProto.ChatPack.message)
  
  return message_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChatPack::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:SocketProto.ChatPack.message)
}

// int32 state = 3;
inline void ChatPack::clear_state() {
  state_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChatPack::_internal_state() const {
  return state_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChatPack::state() const {
  // @@protoc_insertion_point(field_get:SocketProto.ChatPack.state)
  return _internal_state();
}
inline void ChatPack::_internal_set_state(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  state_ = value;
}
inline void ChatPack::set_state(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:SocketProto.ChatPack.state)
}

// -------------------------------------------------------------------

// LoginPack

// string username = 1;
inline void LoginPack::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LoginPack::username() const {
  // @@protoc_insertion_point(field_get:SocketProto.LoginPack.username)
  return _internal_username();
}
inline void LoginPack::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:SocketProto.LoginPack.username)
}
inline std::string* LoginPack::mutable_username() {
  // @@protoc_insertion_point(field_mutable:SocketProto.LoginPack.username)
  return _internal_mutable_username();
}
inline const std::string& LoginPack::_internal_username() const {
  return username_.GetNoArena();
}
inline void LoginPack::_internal_set_username(const std::string& value) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LoginPack::set_username(std::string&& value) {
  
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SocketProto.LoginPack.username)
}
inline void LoginPack::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SocketProto.LoginPack.username)
}
inline void LoginPack::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SocketProto.LoginPack.username)
}
inline std::string* LoginPack::_internal_mutable_username() {
  
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginPack::release_username() {
  // @@protoc_insertion_point(field_release:SocketProto.LoginPack.username)
  
  return username_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginPack::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:SocketProto.LoginPack.username)
}

// string password = 2;
inline void LoginPack::clear_password() {
  password_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LoginPack::password() const {
  // @@protoc_insertion_point(field_get:SocketProto.LoginPack.password)
  return _internal_password();
}
inline void LoginPack::set_password(const std::string& value) {
  _internal_set_password(value);
  // @@protoc_insertion_point(field_set:SocketProto.LoginPack.password)
}
inline std::string* LoginPack::mutable_password() {
  // @@protoc_insertion_point(field_mutable:SocketProto.LoginPack.password)
  return _internal_mutable_password();
}
inline const std::string& LoginPack::_internal_password() const {
  return password_.GetNoArena();
}
inline void LoginPack::_internal_set_password(const std::string& value) {
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LoginPack::set_password(std::string&& value) {
  
  password_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SocketProto.LoginPack.password)
}
inline void LoginPack::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SocketProto.LoginPack.password)
}
inline void LoginPack::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SocketProto.LoginPack.password)
}
inline std::string* LoginPack::_internal_mutable_password() {
  
  return password_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginPack::release_password() {
  // @@protoc_insertion_point(field_release:SocketProto.LoginPack.password)
  
  return password_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginPack::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:SocketProto.LoginPack.password)
}

// -------------------------------------------------------------------

// RoomPack

// string roomid = 1;
inline void RoomPack::clear_roomid() {
  roomid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RoomPack::roomid() const {
  // @@protoc_insertion_point(field_get:SocketProto.RoomPack.roomid)
  return _internal_roomid();
}
inline void RoomPack::set_roomid(const std::string& value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:SocketProto.RoomPack.roomid)
}
inline std::string* RoomPack::mutable_roomid() {
  // @@protoc_insertion_point(field_mutable:SocketProto.RoomPack.roomid)
  return _internal_mutable_roomid();
}
inline const std::string& RoomPack::_internal_roomid() const {
  return roomid_.GetNoArena();
}
inline void RoomPack::_internal_set_roomid(const std::string& value) {
  
  roomid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RoomPack::set_roomid(std::string&& value) {
  
  roomid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SocketProto.RoomPack.roomid)
}
inline void RoomPack::set_roomid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  roomid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SocketProto.RoomPack.roomid)
}
inline void RoomPack::set_roomid(const char* value, size_t size) {
  
  roomid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SocketProto.RoomPack.roomid)
}
inline std::string* RoomPack::_internal_mutable_roomid() {
  
  return roomid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RoomPack::release_roomid() {
  // @@protoc_insertion_point(field_release:SocketProto.RoomPack.roomid)
  
  return roomid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RoomPack::set_allocated_roomid(std::string* roomid) {
  if (roomid != nullptr) {
    
  } else {
    
  }
  roomid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), roomid);
  // @@protoc_insertion_point(field_set_allocated:SocketProto.RoomPack.roomid)
}

// int32 maxnum = 2;
inline void RoomPack::clear_maxnum() {
  maxnum_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoomPack::_internal_maxnum() const {
  return maxnum_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoomPack::maxnum() const {
  // @@protoc_insertion_point(field_get:SocketProto.RoomPack.maxnum)
  return _internal_maxnum();
}
inline void RoomPack::_internal_set_maxnum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  maxnum_ = value;
}
inline void RoomPack::set_maxnum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_maxnum(value);
  // @@protoc_insertion_point(field_set:SocketProto.RoomPack.maxnum)
}

// int32 curnum = 3;
inline void RoomPack::clear_curnum() {
  curnum_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoomPack::_internal_curnum() const {
  return curnum_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoomPack::curnum() const {
  // @@protoc_insertion_point(field_get:SocketProto.RoomPack.curnum)
  return _internal_curnum();
}
inline void RoomPack::_internal_set_curnum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  curnum_ = value;
}
inline void RoomPack::set_curnum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_curnum(value);
  // @@protoc_insertion_point(field_set:SocketProto.RoomPack.curnum)
}

// .SocketProto.RoomState state = 4;
inline void RoomPack::clear_state() {
  state_ = 0;
}
inline ::SocketProto::RoomState RoomPack::_internal_state() const {
  return static_cast< ::SocketProto::RoomState >(state_);
}
inline ::SocketProto::RoomState RoomPack::state() const {
  // @@protoc_insertion_point(field_get:SocketProto.RoomPack.state)
  return _internal_state();
}
inline void RoomPack::_internal_set_state(::SocketProto::RoomState value) {
  
  state_ = value;
}
inline void RoomPack::set_state(::SocketProto::RoomState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:SocketProto.RoomPack.state)
}

// -------------------------------------------------------------------

// FriendRoomPack

// string roomid = 1;
inline void FriendRoomPack::clear_roomid() {
  roomid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& FriendRoomPack::roomid() const {
  // @@protoc_insertion_point(field_get:SocketProto.FriendRoomPack.roomid)
  return _internal_roomid();
}
inline void FriendRoomPack::set_roomid(const std::string& value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:SocketProto.FriendRoomPack.roomid)
}
inline std::string* FriendRoomPack::mutable_roomid() {
  // @@protoc_insertion_point(field_mutable:SocketProto.FriendRoomPack.roomid)
  return _internal_mutable_roomid();
}
inline const std::string& FriendRoomPack::_internal_roomid() const {
  return roomid_.GetNoArena();
}
inline void FriendRoomPack::_internal_set_roomid(const std::string& value) {
  
  roomid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void FriendRoomPack::set_roomid(std::string&& value) {
  
  roomid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SocketProto.FriendRoomPack.roomid)
}
inline void FriendRoomPack::set_roomid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  roomid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SocketProto.FriendRoomPack.roomid)
}
inline void FriendRoomPack::set_roomid(const char* value, size_t size) {
  
  roomid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SocketProto.FriendRoomPack.roomid)
}
inline std::string* FriendRoomPack::_internal_mutable_roomid() {
  
  return roomid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FriendRoomPack::release_roomid() {
  // @@protoc_insertion_point(field_release:SocketProto.FriendRoomPack.roomid)
  
  return roomid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FriendRoomPack::set_allocated_roomid(std::string* roomid) {
  if (roomid != nullptr) {
    
  } else {
    
  }
  roomid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), roomid);
  // @@protoc_insertion_point(field_set_allocated:SocketProto.FriendRoomPack.roomid)
}

// int32 maxnum = 2;
inline void FriendRoomPack::clear_maxnum() {
  maxnum_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FriendRoomPack::_internal_maxnum() const {
  return maxnum_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FriendRoomPack::maxnum() const {
  // @@protoc_insertion_point(field_get:SocketProto.FriendRoomPack.maxnum)
  return _internal_maxnum();
}
inline void FriendRoomPack::_internal_set_maxnum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  maxnum_ = value;
}
inline void FriendRoomPack::set_maxnum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_maxnum(value);
  // @@protoc_insertion_point(field_set:SocketProto.FriendRoomPack.maxnum)
}

// int32 curnum = 3;
inline void FriendRoomPack::clear_curnum() {
  curnum_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FriendRoomPack::_internal_curnum() const {
  return curnum_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FriendRoomPack::curnum() const {
  // @@protoc_insertion_point(field_get:SocketProto.FriendRoomPack.curnum)
  return _internal_curnum();
}
inline void FriendRoomPack::_internal_set_curnum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  curnum_ = value;
}
inline void FriendRoomPack::set_curnum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_curnum(value);
  // @@protoc_insertion_point(field_set:SocketProto.FriendRoomPack.curnum)
}

// .SocketProto.RoomState state = 4;
inline void FriendRoomPack::clear_state() {
  state_ = 0;
}
inline ::SocketProto::RoomState FriendRoomPack::_internal_state() const {
  return static_cast< ::SocketProto::RoomState >(state_);
}
inline ::SocketProto::RoomState FriendRoomPack::state() const {
  // @@protoc_insertion_point(field_get:SocketProto.FriendRoomPack.state)
  return _internal_state();
}
inline void FriendRoomPack::_internal_set_state(::SocketProto::RoomState value) {
  
  state_ = value;
}
inline void FriendRoomPack::set_state(::SocketProto::RoomState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:SocketProto.FriendRoomPack.state)
}

// -------------------------------------------------------------------

// PlayerPack

// string username = 1;
inline void PlayerPack::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& PlayerPack::username() const {
  // @@protoc_insertion_point(field_get:SocketProto.PlayerPack.username)
  return _internal_username();
}
inline void PlayerPack::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:SocketProto.PlayerPack.username)
}
inline std::string* PlayerPack::mutable_username() {
  // @@protoc_insertion_point(field_mutable:SocketProto.PlayerPack.username)
  return _internal_mutable_username();
}
inline const std::string& PlayerPack::_internal_username() const {
  return username_.GetNoArena();
}
inline void PlayerPack::_internal_set_username(const std::string& value) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void PlayerPack::set_username(std::string&& value) {
  
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SocketProto.PlayerPack.username)
}
inline void PlayerPack::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SocketProto.PlayerPack.username)
}
inline void PlayerPack::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SocketProto.PlayerPack.username)
}
inline std::string* PlayerPack::_internal_mutable_username() {
  
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PlayerPack::release_username() {
  // @@protoc_insertion_point(field_release:SocketProto.PlayerPack.username)
  
  return username_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerPack::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:SocketProto.PlayerPack.username)
}

// string playername = 2;
inline void PlayerPack::clear_playername() {
  playername_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& PlayerPack::playername() const {
  // @@protoc_insertion_point(field_get:SocketProto.PlayerPack.playername)
  return _internal_playername();
}
inline void PlayerPack::set_playername(const std::string& value) {
  _internal_set_playername(value);
  // @@protoc_insertion_point(field_set:SocketProto.PlayerPack.playername)
}
inline std::string* PlayerPack::mutable_playername() {
  // @@protoc_insertion_point(field_mutable:SocketProto.PlayerPack.playername)
  return _internal_mutable_playername();
}
inline const std::string& PlayerPack::_internal_playername() const {
  return playername_.GetNoArena();
}
inline void PlayerPack::_internal_set_playername(const std::string& value) {
  
  playername_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void PlayerPack::set_playername(std::string&& value) {
  
  playername_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SocketProto.PlayerPack.playername)
}
inline void PlayerPack::set_playername(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  playername_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SocketProto.PlayerPack.playername)
}
inline void PlayerPack::set_playername(const char* value, size_t size) {
  
  playername_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SocketProto.PlayerPack.playername)
}
inline std::string* PlayerPack::_internal_mutable_playername() {
  
  return playername_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PlayerPack::release_playername() {
  // @@protoc_insertion_point(field_release:SocketProto.PlayerPack.playername)
  
  return playername_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerPack::set_allocated_playername(std::string* playername) {
  if (playername != nullptr) {
    
  } else {
    
  }
  playername_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), playername);
  // @@protoc_insertion_point(field_set_allocated:SocketProto.PlayerPack.playername)
}

// int32 id = 3;
inline void PlayerPack::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerPack::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerPack::id() const {
  // @@protoc_insertion_point(field_get:SocketProto.PlayerPack.id)
  return _internal_id();
}
inline void PlayerPack::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void PlayerPack::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:SocketProto.PlayerPack.id)
}

// .SocketProto.PlayerState state = 4;
inline void PlayerPack::clear_state() {
  state_ = 0;
}
inline ::SocketProto::PlayerState PlayerPack::_internal_state() const {
  return static_cast< ::SocketProto::PlayerState >(state_);
}
inline ::SocketProto::PlayerState PlayerPack::state() const {
  // @@protoc_insertion_point(field_get:SocketProto.PlayerPack.state)
  return _internal_state();
}
inline void PlayerPack::_internal_set_state(::SocketProto::PlayerState value) {
  
  state_ = value;
}
inline void PlayerPack::set_state(::SocketProto::PlayerState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:SocketProto.PlayerPack.state)
}

// .SocketProto.Hero hero = 5;
inline void PlayerPack::clear_hero() {
  hero_ = 0;
}
inline ::SocketProto::Hero PlayerPack::_internal_hero() const {
  return static_cast< ::SocketProto::Hero >(hero_);
}
inline ::SocketProto::Hero PlayerPack::hero() const {
  // @@protoc_insertion_point(field_get:SocketProto.PlayerPack.hero)
  return _internal_hero();
}
inline void PlayerPack::_internal_set_hero(::SocketProto::Hero value) {
  
  hero_ = value;
}
inline void PlayerPack::set_hero(::SocketProto::Hero value) {
  _internal_set_hero(value);
  // @@protoc_insertion_point(field_set:SocketProto.PlayerPack.hero)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SocketProto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::SocketProto::RequestCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SocketProto::RequestCode>() {
  return ::SocketProto::RequestCode_descriptor();
}
template <> struct is_proto_enum< ::SocketProto::ActionCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SocketProto::ActionCode>() {
  return ::SocketProto::ActionCode_descriptor();
}
template <> struct is_proto_enum< ::SocketProto::ReturnCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SocketProto::ReturnCode>() {
  return ::SocketProto::ReturnCode_descriptor();
}
template <> struct is_proto_enum< ::SocketProto::RoomState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SocketProto::RoomState>() {
  return ::SocketProto::RoomState_descriptor();
}
template <> struct is_proto_enum< ::SocketProto::PlayerState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SocketProto::PlayerState>() {
  return ::SocketProto::PlayerState_descriptor();
}
template <> struct is_proto_enum< ::SocketProto::Hero> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SocketProto::Hero>() {
  return ::SocketProto::Hero_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_SocketProto_2eproto
